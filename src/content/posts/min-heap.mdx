---
author: XDong
categories: ["react min-heap"]
date: 2024/02/04
featured: false
image: ./images/coffee_coder.webp
title: Min Heap 最小堆
---

React 在其内部实现中使用了最小堆的概念，特别是在调度算法和优先级更新管理中。React 的并发模式（Concurrent Mode）允许组件在渲染时进行中断和恢复，这就需要一个高效的方式来管理和调度这些更新任务的优先级。这里就是最小堆发挥了作用。

### 最小堆是一种特殊的完全二叉树，它满足两个主要特性：

##### <strong>结构特性：</strong>最小堆是一个完全二叉树，这意味着除了最底层之外，每一层都被完全填满，且最底层从左到右填入。这保证了树的高度始终保持最小。
##### <strong>堆特性：</strong>在最小堆中，每个节点的值都小于或等于其子节点的值。根节点（堆顶）是整个树中的最小元素。

#### 操作最小堆的基本操作包括：

  - 插入（Insertion）：新元素被加到堆的末尾，然后调整其位置，以满足最小堆的条件。这是通过一系列的“上浮”操作完成的，即如果这个元素小于其父节点，就与父节点交换位置，直到恢复堆的特性。

  - 删除最小元素（Extract Min）：由于根节点是最小的，删除操作总是移除根节点的值。删除根节点后，通常将最后一个元素移动到根节点位置，然后进行一系列的“下沉”操作，以恢复堆的特性。如果这个元素大于其任一子节点，则与其最小的一个子节点交换位置，直到恢复堆的特性。

##### 这种数据结构在很多算法和服务中非常有用，比如优先队列、堆排序算法等

```js
// 获取堆顶元素，优先级最高的任务
export function peak(heap) {
  return heap.length === 0 ? null : heap[0];
}

export function push(heap, node) {
  const index = heap.length;
  heap.push(node);
  siftUp(heap, node, index);
}

export function siftUp(heap, node, i) {
  let index = i;
  while (index > 0) {
    const parentIndex = (index - 1) >>> 1;
    const parent = heap[parentIndex];
    if (compare(parent, node) > 0) {
      heap[parentIndex] = node;
      heap[index] = parent;
      index = parentIndex;
    } else {
      return;
    }
  }
}

// 1. 删除堆顶元素
// 2. 向下调整
export function pop(heap) {
  if (heap.length === 0) {
    return null;
  }

  const first = heap[0];
  const last = heap.pop();

  if (first !== last) {
    heap[0] = last;
    siftDown(heap, last, 0);
  }
  return first;
}

function siftDown(heap, node, i) {
  let index = i;
  let length = heap.length;
  let halfLength = length >>> 1;
  while (index < halfLength) {
    const leftIndex = (index + 1) * 2 - 1;
    const left = heap[leftIndex];
    const rightIndex = leftIndex + 1;
    const right = heap[rightIndex];

    if (compare(left, node) < 0) {
      // left < node
      if (rightIndex < length && compare(right, left) < 0) {
        // right 最小
        heap[index] = right;
        heap[rightIndex] = node;
        index = rightIndex;
      } else {
        // left 最小
        heap[index] = left;
        heap[leftIndex] = node;
        index = leftIndex;
      }
    } else if (rightIndex < length && compare(right, node) < 0) {
      // right 最小
      heap[index] = right;
      heap[rightIndex] = node;
      index = rightIndex;
    } else {
      // node 最小
      return;
    }
  }
}

function compare(a, b) {
  // Compare sort index first, then task id.
  return a - b;
  // const diff = a.sortIndex - b.sortIndex;
  // return diff !== 0 ? diff : a.id - b.id;
}

// test
let a = [3, 7, 4, 10, 12, 9, 6, 15, 14];
push(a, 5);
while (1) {
  if (a.length === 0) {
    break;
  }
  console.log(peak(a));
  pop(a);
}
```





